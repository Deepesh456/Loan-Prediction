# -*- coding: utf-8 -*-
"""loan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1njpA2Mp5x1pT-7VTGqQN5tSNgcLlx4uM
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('/content/LoanApprovalPrediction.csv')
df

df.shape

df.head()

df.tail()

df.isna().sum()

df['Gender'].fillna(df['Gender'].mode()[0],inplace=True)
df.isna().sum()

df['Married'].fillna(df['Married'].mode()[0],inplace=True)
df.isna().sum()

df['Dependents'].fillna(df['Dependents'].mode()[0],inplace=True)
df.isna().sum()

df['Self_Employed'].fillna(df['Self_Employed'].mode()[0],inplace=True)
df.isna().sum()

df['LoanAmount'].fillna(df['LoanAmount'].mean(),inplace=True)
df.isna().sum()

df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mean(),inplace=True)
df.isna().sum()

df['Credit_History'].fillna(df['Credit_History'].mean(),inplace=True)
df.isna().sum()

df.dtypes

df.drop(['Loan_ID'],axis=1,inplace=True)

"""Data Visualizations"""

sns.countplot(x=df['Gender'],data=df,color='red')

sns.countplot(x=df['Married'],data=df,color='green')

sns.countplot(x=df['Dependents'],data=df,color='blue')

sns.countplot(x=df['Education'],data=df,color='black')

sns.countplot(x=df['Self_Employed'],data=df,color='yellow')

sns.countplot(x=df['Property_Area'],data=df,color='orange')

x1=['Approved','Not Approved']
y1=df['Loan_Status'].value_counts()
plt.pie(y1,labels=x1,autopct='%1.1f%%')
plt.legend()

# Encoding

from sklearn.preprocessing import LabelEncoder
lb=LabelEncoder()
df['Gender']=lb.fit_transform(df['Gender'])
df

df['Married']=lb.fit_transform(df['Married'])
df

df['Dependents']=lb.fit_transform(df['Dependents'])
df

df['Education']=lb.fit_transform(df['Education'])
df

df['Self_Employed']=lb.fit_transform(df['Self_Employed'])
df

df['Property_Area']=lb.fit_transform(df['Property_Area'])
df

x=df.iloc[:,:-1].values
x

y=df.iloc[:,-1].values
y

df.dtypes

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.30,random_state=42)
x_train

x_test

y_train

y_test

# Normalization

from sklearn.preprocessing import StandardScaler
scaler=StandardScaler()
scaler.fit(x_train)
x_train=scaler.transform(x_train)
x_test=scaler.transform(x_test)
x_train

x_test

# Model Creation

from sklearn.neighbors import KNeighborsClassifier
knn=KNeighborsClassifier(n_neighbors=7)
knn.fit(x_train,y_train)
y_pred=knn.predict(x_test)
y_pred

# Performance Evaluation

from sklearn.metrics import confusion_matrix,accuracy_score,ConfusionMatrixDisplay
cm=confusion_matrix(y_test,y_pred)
score=accuracy_score(y_test,y_pred)
labels=['N','Y']
cmd=ConfusionMatrixDisplay(cm,display_labels=labels)

print('Confusion Matrix is')
cm

print('Accuracy Score is',accuracy_score(y_test,y_pred))

cmd.plot()

from sklearn.metrics import classification_report
report=classification_report(y_test,y_pred)
print(report)

from sklearn.model_selection import GridSearchCV

parameters={'n_neighbors':[3,5,7,9],'weights':['uniform','distance']}
gs=GridSearchCV(knn,parameters,cv=10,scoring='accuracy')
gs.fit(x_train,y_train)

print(gs.best_params_)

best_model=KNeighborsClassifier(n_neighbors=9,weights='uniform')
best_model.fit(x_train,y_train)
y_pred1=best_model.predict(x_test)
y_pred1

score1=accuracy_score(y_test,y_pred1)
print('Accuracy_Score_Updated',score1)

